[state=no-title-footer]
== Die Microprofile API

[.center]
Ein Standard für Microservices

== Microprofile API

--
image::microprofile.png[width=700]
* Sammlung von Spezifikationen
* Fokus auf Microservices
--

--
image::MicroProfile3.3.png[width=900]
--

[.columns.text-center]
== Microprofile API
--
[.margin-bottom-wide]
image::quarkus.jpg[width=200]

[.margin-bottom-wide]
image::thorntail.png[width=250]

[.margin-bottom-wide]
image::openliberty.png[width=250]
--

--
[.margin-bottom-wide]
image::payara.jpeg[width=250]

[.margin-bottom-wide]
image::helidon.png[width=250]

[.margin-bottom-wide]
image::kumuluz.png[width=250]
--

== Microprofile API: Relevante Bestandteile

1. *Configuration*:
Einheitlicher Ansatz zur Konfiguration.
1. *Health*:
Endpunkt für Health, liveness und readiness Checks
2. *Fault Tolerance*:
Ausfall-Strategie (z.B. Timeouts, Retry Policy, Fallback, Circuit Breaker)
3. *Metrics*:
Fachliches Monitoring (z.B. Datensätze) an externe System
4. *OpenAPI*:
Beschreibung der REST-Schnittstelle
5. *OpenTracing*:
Intrumentation für JAX-RS und CDI
6. *Rest Client*
Aufbauend auf JAX-RS, client-funktionalität

== 2. Health: Klassischer Health-Check (deprecated)

Dependency

[source, xml]
----
<dependency>
  <groupId>io.quarkus</groupId>
  <artifactId>quarkus-smallrye-health</artifactId>
</dependency>
----

Implementierung
[source, java]
----
@Health
@ApplicationScoped
public class OldStyleHealthCheck implements HealthCheck {

    @Override
    public HealthCheckResponse call() {
        double dice = Math.random();
        HealthCheckResponseBuilder builder = HealthCheckResponse.named("dice");
        if(dice >= 0.5) {
            builder.up();
        } else {
            builder.down().withData("valueOfDice", "" + dice);
        }
        return builder.build();
    }
}
----

Vor Microprofile 3.0

== 2. Health: Klassischer Health-Check (deprecated)

[.heading]
Aufruf des Checks

`curl http://127.0.0.1:8080/health`

[source,json]
----
{
    "status": "DOWN",
    "checks": [
        {
            "name": "dice",
            "status": "DOWN",
            "data": {
                "valueOfDice": "0.19585549288164417"
            }
        },
        {
            "name": "Database connections health check",
            "status": "UP"
        }
    ]
}
----

== 2. Health: Liveness and Readiness checks (Microprofile 3.0)

Konzept:

* *Readiness*: Der Service kann aktuell (temporär) Daten verarbeiten / nicht verarbeiten.
* *Liveness*: Der Service is aktiv oder dauerhaft gestört.

Eigenschaften:

* Feinere Granularität
* Aufruf:
** `curl http://127.0.0.1:8080/health` (kombiniert)
** `curl http://127.0.0.1:8080/health/live`
** `curl http://127.0.0.1:8080/health/ready`
** `chrome http://127.0.0.1:8080/health-ui` (kein Standard)

link:https://quarkus.io/guides/microprofile-health[-> Quarkus Microprofile Health]

link:https://download.eclipse.org/microprofile/microprofile-health-2.1/microprofile-health-spec.html[-> MicroProfile Health Specification]

== 2. Health: Liveness and Readiness checks (Microprofile 3.0)

*Liveness: `@Liveness`*

[source,java]
----
@Liveness
@ApplicationScoped
public class MyLivenessCheck implements HealthCheck {

    @Override
    public HealthCheckResponse call() {
        // Inhalt
    }
}
----

*Readiness: `@Readiness`*

[source,java]
----
@Readiness
@ApplicationScoped
public class MyReadinessCheck implements HealthCheck {

    @Override
    public HealthCheckResponse call() {
        // Inhalt
    }
}
----

link:https://quarkus.io/guides/microprofile-health[-> Guide: Quarkus Microprofile Health]

== Aufgabe 4.1: lesson04-health

*Aufgabenstellung*:

* Implementieren Sie Readiness und Liveness für den Order-Service
** Readiness: Weniger als 42 Bestellungen Status: `IN_PROGRESS`
** Liveness: Keine Bestellung Status: `LOST`
* Testen Sie mit Postman oder Curl
* Überprüfen Sie die Ausgabe in der Health-UI
* Optional: Implementieren Sie einen klassischen Health-Check *`dice`*, der würfelt.

*Hinweise*:

1. Im Ordner `lesson04-health/lesson04` befindet sich bereits ein Skelett. Es entspricht der Beispiellösung aus Aufgabe 3.4.
2. Eine Beispiellösung finden Sie im Ordner `solutions/lesson04-health/lesson04`

link:https://quarkus.io/guides/microprofile-health[-> Guide: Quarkus Microprofile Health]

== 3. Fault Tolerance API

[.heading]
Fault Tolerance API: Strategien bei Nicht-Erreichbarkeit

* *Timeout*: Wenn die Antwort ausbleibt
* *Fallback*: Wenn ein Fehler auftritt
* *Retry*: Wie soll ein Aufruf wiederholt werden?
* *Bulkhead*: Isolation lokaler Fehler
* *Circuit Breaker*: fast-fail: Überlast vermeiden
* (*Asynchronous*): Verhalten bei asynchronen Aufrufen

Dependency:
[source,xml]
----
<dependency>
    <groupId>io.quarkus</groupId>
    <artifactId>quarkus-smallrye-fault-tolerance</artifactId>
</dependency>
----

link:https://quarkus.io/guides/microprofile-fault-tolerance[-> Guide: Quarkus Fault Tolerance] |
link:https://download.eclipse.org/microprofile/microprofile-fault-tolerance-2.0.4/microprofile-fault-tolerance-spec.html[-> Microprofile Fault Tolerance Specification]

== 3. Fault Tolerance: Timeout, Fallback, Retries
[source, java]
----
@GET
@Transactional
@Timeout(250)
@Fallback(fallbackMethod = "sorry")
@Retry(maxRetries = 5)
public List index(){
    return this.repository.listAll();
}
// Fallback, index times out
private List sorry(){
    return new ArrayList<>();
}
----

Konsequenzen

* Nach 250ms wird ein Request abgebrochen
* Es werden bis zu 5 Requests durchgeführt
* Danach wird die Methode `sorry()` aufgerufen -> leere Liste als Rückgabe

link:https://download.eclipse.org/microprofile/microprofile-fault-tolerance-2.0.4/microprofile-fault-tolerance-spec.html[-> Microprofile Fault Tolerance Specification]

link:https://download.eclipse.org/microprofile/microprofile-fault-tolerance-2.0.2/apidocs/index.html?org/eclipse/microprofile/faulttolerance/Retry.html[->
API Documentation]

== 3. Fault Tolerance: Circuit Breaker

Ziel: Überlast in Fehler-Situationen verhindern.

Der Circuit-Breaker definiert Zustände:

* Closed state: Der Stromkreis ist geschlossen, Requests werden bearbeitet
* Half-open circuit: Einige Fehler treten auf, Requests werden in der Mehrzahl bearbeitet
* Open state: Zu viele Fehler treten auf. Anfragen werden temporär zurück gewiesen

== 3. Fault Tolerance: Circuit Breaker: Verwendung

[source,java]
----
@POST
@Transactional
@CircuitBreaker(successThreshold = 5, requestVolumeThreshold = 4,
        failureRatio = 0.75, delay = 1000)
public Response create(/* ... */)){
    // ...
}
----

*Open state*

* Für `delay = 1000 ms`, falls
* Von den letzten `requestVolumeThreshold = 4`
* 75% (d.h. `failureRatio = 0.75`) fehlerhaft sind.
* Danach: Half open

*Half open* - so lange bis:

* `successThreshold = 5` Requests hintereinander erfolgreich waren oder (-> Closed state)
* Alternativ: Open state auslöst

link:https://download.eclipse.org/microprofile/microprofile-fault-tolerance-2.0.2/apidocs/index.html?org/eclipse/microprofile/faulttolerance/Retry.html[-> org.eclipse.microprofile.faulttolerance.CircuitBreaker]

== 3. Fault Tolerance: Bulkhead

Ziel: Überlast im Normalfall verhindern

[source,java]
----
@Asynchronous
@Bulkhead(value = 5)
private Future doSomething(Order o) {
    // ...
}
----
Ziel: Gleichzeitige Ausführung einschränken (semaphore)

* *Mit* `@Asynchronous`: *Thread-Isolation*, d.h. `value = 5` Threads in Pool
* *Sonst*: Zählende Semaphore, kein eigener Thread-Pool

API Dokumentation

* link:https://download.eclipse.org/microprofile/microprofile-fault-tolerance-2.0.2/apidocs/index.html?org/eclipse/microprofile/faulttolerance/Asynchronous.html[org.eclipse.microprofile.faulttolerance.Asynchronous]
* https://download.eclipse.org/microprofile/microprofile-fault-tolerance-2.0.2/apidocs/index.html?org/eclipse/microprofile/faulttolerance/Bulkhead.html[org.eclipse.microprofile.faulttolerance.Bulkhead]

link:https://de.wikipedia.org/wiki/Semaphor_(Informatik)[-> Wikipedia: Semaphor (Informatik)]

== Aufgabe 4.2: lesson04-fault-tolerance

*Aufgabenstellung*:

Implementieren Sie verschiedene Fault Tolerance Strategien für die `Order Resource`

* Index: Nach einem Timeout von 250ms werden Anfragen abgebrochen
** Eine Anfrage wird bis zu 5 mal wiederholt.
** Falls die Anfrage fehl schlägt, wird eine leere Liste zurück gegeben.
* Create:
** Falls die Annahme von mindestens 3 der 4 letzten Bestellung fehlschlägt, sollen für 1 Sekunde keine Bestellungen erstellt werden.
** Nach 5 erfolgreich angenommenen Bestellungen, steht die Annahme wieder voll zur Verfügung.
* Update:
** Es gibt nur 5 Lieferfahrzeuge, d.h. es dürfen maximal 5 Pizzas im Status `IN_DELIVERY` ausgeliefert werden.
** Verwenden Sie einen eigenen Threadpool.

*Hinweise*:

1. Im Ordner `lesson04-fault-tolerance/lesson04` befindet sich bereits ein Skelett. Es entspricht der Beispiellösung aus Aufgabe 4.1.
2. Eine Beispiellösung finden Sie im Ordner `solutions/lesson04-fault-tolerance/lesson04`

=== 4. Metrics API: Fachloches Logging


